{"ts":1366910892192,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1366910906257,"patch":[[{"diffs":[[1,"/* GET FONT METRICS\n----------------------- */\n\n(function() {\n\nvar image = document.createElement(\"img\");\nimage.width = 42;\nimage.height = 1;\nimage.src = op_8x8.data;\nimage.style.cssText = \"display: inline\";\n\ngetMetrics = function(text, font) {\n  var metrics = document.getElementById(\"metrics\");\n\tif (metrics) {\t\n\t\tmetrics.style.cssText = \"display: block\";\n\t\tvar parent = metrics.firstChild;\n\t\tparent.firstChild.textContent = text;\n\t} else {\n\t\t// setting up html used for measuring text-metrics\n\t\tvar parent = document.createElement(\"span\");\n\t\tparent.appendChild(document.createTextNode(text));\n\t\tparent.appendChild(image);\n\t\tvar metrics = document.createElement(\"div\");\n\t\tmetrics.id = \"metrics\";\n\t\tmetrics.appendChild(parent);\n\t\tdocument.body.insertBefore(metrics, document.body.firstChild);\n\t}\n\t\n\t// direction of the text\n\tvar direction = window.getComputedStyle(document.body, \"\")[\"direction\"];\n\n\t// getting css equivalent of ctx.measureText()\n\tparent.style.cssText = \"font: \" + font + \"; white-space: nowrap; display: inline;\";\n\tvar width = parent.offsetWidth;\n\tvar height = parent.offsetHeight;\n\n\t// capturing the \"top\" and \"bottom\" baseline\n\tparent.style.cssText = \"font: \" + font + \"; white-space: nowrap; display: block;\";\n\tvar top = image.offsetTop;\n\tvar bottom = top - height;\n\n\t// capturing the \"middle\" baseline\n\tparent.style.cssText = \"font: \" + font + \"; white-space: nowrap; line-height: 0; display: block;\";\n\tvar middle = image.offsetTop + 1;\n\t\n\t// cleanup\n\tmetrics.style.display = \"none\";\n\n\treturn {\n\t\tdirection: direction,\n\t\ttop: top,\n\t\tmiddle: middle,\n\t\tbottom: bottom,\n\t\theight: height,\n\t\twidth: width\n\t};\n};\n\ngetBoundingBox = function(props) {\n\tvar ctx = props.ctx;\n\tvar text = props.text;\n\tvar bboxHeight = props.bboxHeight;\n\tvar bboxWidth = props.bboxWidth;\n\tvar forceHeight = props.forceHeight;\n\tvar flip = props.flip || false;\n\tvar drawBaseline = props.drawBaseline || false;\n\t// setting up the canvas\n\tctx.save();\n\tctx.font = props.font;\n\t// Offsets keep the font in-screen when otherwise clipped\n\tvar offsetx = bboxHeight;\n\tvar offsety = bboxHeight;\n\t// \n\tvar canvasWidth = ctx.canvas.width = Math.round(bboxWidth + offsetx);\n\tvar canvasHeight = ctx.canvas.height = (forceHeight ? forceHeight : bboxHeight) + offsety;\n\tvar pixelWidth = canvasWidth * 4;\n\tif (typeof(props.baseline) == \"string\") {\n\t\toffsety = 0; // using <canvas> baseline\n\t\tctx.textBaseline = props.baseline;\n\t}\n\t// ctx.font has to be called twice because resetting the size resets the state\n\tif (flip) ctx.scale(1, -1);\n\tctx.font = props.font;\n\tctx.fillText(text, offsetx / 1.5, offsety);\n\t// drawing baseline\n\tif (drawBaseline) {\n\t\tctx.fillRect(0, forceHeight / 2, ctx.canvas.width, 1);\n\t}\n\t// grabbing image data\n\tvar imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n\tvar data = imageData.data;\n\tvar ret = {};\n\t// calculating left\n\tvar left = 0;\n\tvar col = 0, row = 0; // left bounds\n\twhile (row < canvasHeight && col < canvasWidth) {\n\t\tif (data[(row * pixelWidth) + (col * 4) + 3]) { \n\t\t\tleft = (col - offsetx / 1.5);\n\t\t\tbreak;\n\t\t}\n\t\trow ++;\n\t\tif (row % canvasHeight == 0) {\n\t\t\trow = 0;\n\t\t\tcol++;\n\t\t}\n\t}\n\tret.left = -left;\n\t// calculating right\n\tvar right = 0;\n\tvar col = canvasWidth, row = 0; // right bounds\n\twhile (row < canvasHeight && col > 0) {\n\t\tif (data[(row * pixelWidth) + (col * 4) + 3]) {\n\t\t\tright = (col - offsetx / 1.5) + 1;\n\t\t\tbreak;\n\t\t}\n\t\trow ++;\n\t\tif (row % canvasHeight == 0) {\n\t\t\trow = 0;\n\t\t\tcol --;\n\t\t}\n\t}\n\tret.right = right;\n\tret.width = (right - left);\n\t// calculating top\n\tvar top = 0;\n\tvar pos = 0;\n\twhile (pos < data.length) {\n\t\tif (data[pos + 3]) {\n\t\t\tpos -= pos % pixelWidth; // back to beginning of the line\n\t\t\ttop = (pos / 4) / canvasWidth; // calculate pixel position\n\t\t\tbreak;\n\t\t}\n\t\tpos += 4;\n\t}\n\tret.top = top;\n\t// calculating bottom\n\tvar bottom = 0;\t\n\tvar pos = data.length;\n\twhile (pos > 0) {\n\t\tif (data[pos + 3]) {\n\t\t\tpos += pixelWidth - (pos % pixelWidth); // to the end of the line\n\t\t\tbottom = (pos / 4) / canvasWidth;\n\t\t\tbreak;\n\t\t}\n\t\tpos -= 4;\n\t}\n\tret.height = (bottom - top);\n\tret.bottom = ret.height + ret.top;\n\tctx.restore();\n\t// returning metrics\n\treturn ret;\n};\n\n})();"]],"start1":0,"start2":0,"length1":0,"length2":4123}]],"length":4123,"saved":false}
